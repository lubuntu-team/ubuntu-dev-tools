#!/usr/bin/python
#
# Copyright (C) 2010, Benjamin Drung <bdrung@ubuntu.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import debian.deb822
import glob
import optparse
import os
import sys

CONTROL_LIST_FIELDS = (
    "Breaks",
    "Build-Depends",
    "Build-Depends-Indep",
    "Conflicts",
    "Depends",
    "Enhances",
    "Provides",
    "Recommends",
    "Replaces",
    "Suggests",
    "Xb-Npp-MimeType",
)

class Control(object):
    def __init__(self, filename, cleanup):
        assert os.path.isfile(filename), "%s does not exist." % (filename)
        self.filename = filename
        sequence = open(filename)
        if cleanup:
            sequence = map(lambda l: l.rstrip(), sequence.readlines())
        self.paragraphs = list()
        for paragraph in debian.deb822.Deb822.iter_paragraphs(sequence):
            self.paragraphs.append(paragraph)

    def save(self, filename=None):
        if filename:
            self.filename = filename
        content = u"\n".join(map(lambda x: x.dump(), self.paragraphs))
        f = open(self.filename, "w")
        f.write(content.encode("utf-8"))
        f.close()

    def wrap_and_sort(self, wrap_always, short_indent):
        for paragraph in self.paragraphs:
            for field in CONTROL_LIST_FIELDS:
                if field in paragraph:
                    self._wrap_field(paragraph, field, wrap_always,
                                     short_indent)
            if "Uploaders" in paragraph:
                self._wrap_field(paragraph, "Uploaders", wrap_always,
                                 short_indent, False)

    def _wrap_field(self, control, entry, wrap_always, short_indent, sort=True):
        packages = map(lambda x: x.strip(), control[entry].split(","))
        if sort:
            # Remove duplicate entries
            packages = set(packages)
            # Not explicitly disallowed by Policy but known to break QA tools:
            if "" in packages:
                packages.remove("")
            packages = sort_list(packages)

        length = len(entry) + 2 * len(packages) + sum(map(len, packages))
        if wrap_always or length > 80:
            indentation = " "
            if not short_indent:
                indentation *= len(entry) + 2
            packages_with_indention = map(lambda x: indentation + x, packages)
            packages_with_indention = ",\n".join(packages_with_indention)
            if short_indent:
                control[entry] = "\n" + packages_with_indention
            else:
                control[entry] = packages_with_indention.strip()
        else:
            control[entry] = ", ".join(packages).strip()


class Install(object):
    def __init__(self, filename):
        self.open(filename)

    def open(self, filename):
        assert os.path.isfile(filename), "%s does not exist." % (filename)
        self.filename = filename
        self.content = open(filename).readlines()

    def save(self, filename=None):
        if filename:
            self.filename = filename
        f = open(self.filename, "w")
        f.write("".join(self.content))
        f.close()

    def sort(self):
        self.content = sorted(self.content)


def remove_trailing_whitespaces(filename):
    assert os.path.isfile(filename), "%s does not exist." % (filename)
    content = open(filename).read().rstrip() + "\n"
    lines = content.split("\n")
    lines = map(lambda l: l.rstrip(), lines)
    new_content = "\n".join(lines)
    f = open(filename, "w")
    f.write(new_content)
    f.close()

def sort_list(l):
    normal = filter(lambda x: not x.startswith("${"), l)
    param = filter(lambda x: x.startswith("${"), l)
    return sorted(normal) + sorted(param)

def main(script_name, cleanup, wrap_always, short_indent, verbose=False):
    if not os.path.isdir("debian"):
        print >> sys.stderr, "%s: Error: No debian directory found." % \
                             (script_name)
        sys.exit(1)

    control_files = filter(os.path.isfile,
            ["debian/control", "debian/control.in"])
    for control_file in control_files:
        if verbose:
            print control_file
        control = Control(control_file, cleanup)
        control.wrap_and_sort(wrap_always, short_indent)
        control.save()

    copyright_files = filter(os.path.isfile,
            ["debian/copyright", "debian/copyright.in"])
    for copyright_file in copyright_files:
        if verbose:
            print copyright_file
        remove_trailing_whitespaces(copyright_file)

    install_files = sorted(glob.glob("debian/*.install"))
    if os.path.isfile("debian/install"):
        install_files.insert(0, "debian/install")
    for install_file in install_files:
        if verbose:
            print install_file
        install = Install(install_file)
        install.sort()
        install.save()

if __name__ == "__main__":
    script_name = os.path.basename(sys.argv[0])
    usage = "%s [options]" % (script_name)
    epilog = "See %s(1) for more info." % (script_name)
    parser = optparse.OptionParser(usage=usage, epilog=epilog)

    parser.add_option("-a", "--wrap-always", dest="wrap_always",
                      help="wrap lists even if they fit into one 80 character "
                           "long line", action="store_true", default=False)
    parser.add_option("-s", "--short-indent", dest="short_indent",
                      help="only indent wrapped lines by one space (default is "
                           "in-line with the field name)", action="store_true",
                      default=False)
    parser.add_option("-n", "--no-cleanup", help="don't cleanup whitespaces",
                      dest="cleanup", action="store_false", default=True)
    parser.add_option("-v", "--verbose", help="print more information",
                      dest="verbose", action="store_true", default=False)

    (options, args) = parser.parse_args()

    if len(args) != 0:
        print >> sys.stderr, ("%s: Error: Unsupported additional parameters "
                              "specified: %s") % (script_name, ", ".join(args))
        sys.exit(1)

    main(script_name, options.cleanup, options.wrap_always,
         options.short_indent, options.verbose)
