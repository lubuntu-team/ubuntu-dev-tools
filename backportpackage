#!/usr/bin/python
# -*- coding: utf-8 -*-
# ##################################################################
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See file /usr/share/common-licenses/GPL-2 for more details.
#
# ##################################################################

import logging
import optparse
import os
import shutil
import subprocess
import sys
import tempfile

from debian.deb822 import Dsc
import launchpadlib.launchpad

devnull = open('/dev/null', 'r+')
lp = None

def error(msg, *args, **kwargs):
    logging.error(msg, *args, **kwargs)
    sys.exit(1)

def parse(args):
    usage = 'Usage: %prog [options]'
    p = optparse.OptionParser(usage)
    p.add_option('-t', '--to',
                 dest='dest_releases',
                 default=[],
                 action='append',
                 help='Backport to DEST release (required)',
                 metavar='DEST')
    p.add_option('-f', '--from',
                 dest='source_release',
                 default=None,
                 help='Backport from SOURCE release (defaults to devel release)',
                 metavar='SOURCE')
    p.add_option('-v', '--version',
                 dest='version',
                 default=None,
                 help='Package version to backport (verified if source release also specified)',
                 metavar='VERSION')
    p.add_option('-s', '--source',
                 dest='package',
                 help='Backport SOURCE package (required)',
                 metavar='SOURCE')
    p.add_option('-u', '--upload',
                 dest='upload',
                 help='Specify an upload destination (required)',
                 metavar='UPLOAD')
    p.add_option('-l', '--launchpad',
                 dest='launchpad',
                 default='production',
                 help='Launchpad instance to connect to (default %default)',
                 metavar='INSTANCE')

    opts, args = p.parse_args(args)
    if len(args):
        p.error('Invalid arguments')
    if not opts.package:
        p.error('You must specify a package to backport')
    if not opts.dest_releases:
        p.error('You must specify at least one destination release')
    if not opts.upload:
        p.error('You must specify an upload destination')

    return opts, args

def find_release_package(workdir, opts):
    ubuntu = lp.distributions['ubuntu']
    archive = ubuntu.main_archive
    series = ubuntu.getSeries(name_or_version=opts.source_release)
    status = 'Published'
    for pocket in ('Updates', 'Security', 'Release'):
        try:
            srcpkg = archive.getPublishedSources(source_name=opts.package,
                                                 distro_series=series,
                                                 pocket=pocket,
                                                 status=status,
                                                 exact_match=True)[0]
            break
        except IndexError:
            continue
    else:
        error('Unable to find package %s in release %s' % (package, opts.source_release))

    if opts.version and opts.version != srcpkg.source_package_version:
        error('Requested backport of version %s but %s in %s is at version %s' %
              (opts.version, opts.package, opts.source_release, srcpkg.source_package_version))

    return srcpkg

def find_version_package(workdir, opts):
    ubuntu = lp.distributions['ubuntu']
    archive = ubuntu.main_archive
    try:
        # Might get more than one (i.e. same version in multiple
        # releases), but they should all be identical
        return archive.getPublishedSources(source_name=opts.package,
                                           version=opts.version)[0]
    except IndexError:
        error('Package %s was never published with version %s in Ubuntu' %
              (opts.package, opts.version))

def fetch_package(workdir, opts):
    # Returns the path to the .dsc file that was fetched
    ubuntu = lp.distributions['ubuntu']

    if not opts.source_release and not opts.version:
        opts.source_release = lp.distributions['ubuntu'].current_series.name

    # If source_release is specified, then version is just for
    # verification
    if opts.source_release:
        srcpkg = find_release_package(workdir, opts)
    else:
        srcpkg = find_version_package(workdir, opts)

    for f in srcpkg.sourceFileUrls():
        if f.endswith('.dsc'):
            if 0 != subprocess.call(['dget',
                                     '--download-only',
                                     '--allow-unauthenticated',
                                     f],
                                    cwd=workdir):
                error('Error went wrong fetching the source package')

            return os.path.join(workdir, os.path.basename(f))
    else:
        error('Package %s contains no .dsc file' % opts.package)

def main(args):
    global lp

    logging.basicConfig(level=logging.INFO)
    os.environ['DEB_VENDOR'] = 'Ubuntu'

    opts, _ = parse(args[1:])
    package = opts.package
    source_release = opts.source_release
    dest_releases = opts.dest_releases
    upload = opts.upload

    script_name = os.path.basename(sys.argv[0])
    lp = launchpadlib.launchpad.Launchpad.login_anonymously(script_name,
                                                            opts.launchpad)

    tmpdir = tempfile.mkdtemp(prefix='backportpackage-')
    try:
        dscfile = fetch_package(tmpdir, opts)

        dsc = Dsc(open(os.path.join(tmpdir, dscfile)))
        v = dsc['Version']

        for dest_release in dest_releases:
            srcdir = os.path.join(tmpdir, package)
            if 0 != subprocess.call(['dpkg-source',
                                     '-x',
                                     dscfile,
                                     package],
                                    cwd=tmpdir):
                error('Something went wrong unpacking package %s' % package)

            bp_version = v + ('~%s1' % dest_release)
            bp_dist = dest_release
            if upload.startswith('ppa:'):
                bp_version += '~ppa1'
            elif upload == 'ubuntu':
                bp_dist += '-backports'
            if 0 != subprocess.call(['dch',
                                     '--force-bad-version',
                                     '--preserve',
                                     '--newversion', bp_version,
                                     '--distribution', dest_release,
                                     'No-change backport to %s' % dest_release],
                                    cwd=srcdir):
                error('Something went wrong updating the package changelog')
            if 0 != subprocess.call(['debuild', '-S', '-sa'],
                                    cwd=srcdir):
                error('Something went wrong while building the source package')

            if ':' in bp_version:
                bp_version = bp_version[bp_version.find(':')+1:]

            print 'Please check the package in file://%s carefully' % tmpdir
            while True:
                answer = raw_input('Do you still want to upload this to %s? [Y/n] ' % upload).strip().lower()
                if answer in ('', 'y', 'yes'):
                    if 0 != subprocess.call(['dput',
                                             upload,
                                             '%s_%s_source.changes' % (package, bp_version)],
                                            cwd=tmpdir):
                        error('Something went wrong uploading the package %s to %s' % package, upload)

                    break
                elif answer in ('n', 'no'):
                    break
            shutil.rmtree(srcdir)
    finally:
        shutil.rmtree(tmpdir)

if __name__ == '__main__':
    sys.exit(main(sys.argv))
