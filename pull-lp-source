#!/usr/bin/python
#
# pull-lp-source -- pull a source package from Launchpad
# Basic usage: pull-lp-source <source package> [<release>]
#
# Copyright (C) 2008, Iain Lane <iain@orangesquash.org.uk>,
#               2010, Stefano Rivera <stefanor@ubuntu.com>
#
# ##################################################################
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See file /usr/share/common-licenses/GPL for more details.
#
# ##################################################################


import os
import sys
import subprocess
import urllib
from optparse import OptionParser

from ubuntutools.config import UDTConfig
from ubuntutools.logger import Logger
from ubuntutools.lp.lpapicache import Distribution, Launchpad
from ubuntutools.lp.udtexceptions import (SeriesNotFoundException,
        PackageNotFoundException, PocketDoesNotExistError)
from ubuntutools.misc import splitReleasePocket, dsc_url

def main():
    usage = "Usage: %prog <package> [release]"
    opt_parser = OptionParser(usage)
    opt_parser.add_option('-d', '--download-only',
                          dest='download_only', default=False,
                          action='store_true',
                          help="Do not extract the source package")
    opt_parser.add_option('-m', '--mirror', metavar='UBUNTU_MIRROR',
                          dest='ubuntu_mirror',
                          help='Preferred Ubuntu mirror (default: Launchpad)')
    opt_parser.add_option('--no-conf',
                          dest='no_conf', default=False, action='store_true',
                          help="Don't read config files or environment "
                               "variables")
    (options, args) = opt_parser.parse_args()
    if not args:
        opt_parser.error("Must specify package name")

    config = UDTConfig(options.no_conf)
    if options.ubuntu_mirror is None:
        options.ubuntu_mirror = config.get_value('UBUNTU_MIRROR')

    # Login anonymously to LP
    Launchpad.login_anonymously()

    package = str(args[0]).lower()

    if len(args) >= 2: # Custom distribution specified.
        release = str(args[1]).lower()
    else:
        release = os.getenv('DIST') or (Distribution('ubuntu')
                                        .getDevelopmentSeries().name)

    try:
        (release, pocket) = splitReleasePocket(release)
    except PocketDoesNotExistError, error:
        Logger.error(error)
        sys.exit(1)

    try:
        spph = Distribution('ubuntu').getArchive().getSourcePackage(package,
                                                                    release,
                                                                    pocket)
    except (SeriesNotFoundException, PackageNotFoundException), error:
        Logger.error(error)
        sys.exit(1)

    urls = []
    if options.ubuntu_mirror:
        urls.append(dsc_url(options.ubuntu_mirror, spph.getComponent(),
                            package, spph.getVersion()))
    dsc_url = [url for url in spph.sourceFileUrls() if url.endswith('.dsc')]
    assert dsc_url, 'No .dsc file found'
    urls.append(urllib.unquote(dsc_url[0]))

    Logger.normal('Fetching the source for %s from %s (%s)...',
                  package, release.capitalize(), pocket)
    for url in urls:
        cmd = ('dget', '-u' + ('d' if options.download_only else 'x'), url)
        Logger.command(cmd)
        return_code = subprocess.call(cmd)
        if return_code == 0:
            Logger.normal("Success!")
            sys.exit(0)

    Logger.error('Failed to fetch and extrace the source. '
                 'Please check the output for the error.')
    sys.exit(1)

if __name__ == '__main__':
    main()
