#!/usr/bin/python
#
# Copyright (C) 2007, Canonical Ltd.
# Copyright (C) 2010, Benjamin Drung <bdrung@ubuntu.com>
#
# It was initial written by Daniel Holbach.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 3.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See file /usr/share/common-licenses/GPL-3 for more details.

import getopt
import os
import re
import subprocess
import sys
import logging
import glob
import fnmatch

from ubuntutools.lp.libsupport import get_launchpad
from ubuntutools.requestsync.common import raw_input_exit_on_ctrlc

COMMAND_LINE_SYNTAX_ERROR = 1
VERSION_DETECTION_FAILED = 2

def get_version(title):
	m = re.search("[() ][0-9][0-9a-zA-Z.:+-]*", title)
	if m is None:
		print >> sys.stderr, "Version could not be detected. Please specify it with -V."
		sys.exit(VERSION_DETECTION_FAILED)
	return m.group(0).strip("() ")

def strip_epoch(version):
	parts = version.split(':')
	if len(parts) > 1:
		del parts[0]
	version = ':'.join(parts)
	return version

def LogCall(command):
	command = map(str, command)
	logging.info("Running %s", " ".join(command))
	return command

def get_source(package, version, section):
	assert section in ("main", "contrib", "non-free")

	workdir = "/tmp/ack-sync"
	if not os.path.isdir(workdir):
		os.makedirs(workdir)
	os.chdir(workdir)
	
	if package.startswith("lib"):
		group = package[0:4]
	else:
		group = package[0]

	dsc_file = package + "_" + strip_epoch(version) + ".dsc"
	location = os.path.join("http://ftp.debian.org/debian/pool", section, group, package, dsc_file)
	#print "location:", location
	subprocess.check_call(["dget", "-u", location])
	return dsc_file

def build_source(dsc_file):
	# TODO: use release-info (once available)
	dist = "lucid"
	try:
		if sbuild:
			subprocess.check_call(LogCall(["sbuild", "-c", dist,"-A", dsc_file]))
		else:
			subprocess.check_call(LogCall(["sudo", "env", "DIST=" + dist, "pbuilder", "build", dsc_file]))
	except subprocess.CalledProcessError:
		print >> sys.stderr, "E: %s failed to build." % (dsc_file)
		sys.exit(1)

def test_install(dsc_file):
	# TODO: use release-info (once available)
	dist = "lucid"
	changes_files=glob.glob(os.path.splitext(dsc_file)[0]+"_*.changes")
	changes_file = ""

	for temp_file in changes_files:
		if not fnmatch.fnmatch(temp_file, '*_source.changes'):
			changes_file = temp_file

	if not (os.path.isfile(changes_file)): # if no file exists at all => exit
		print >> sys.stderr, "E: No .changes file has been generated."
		sys.exit(1)

	try:
		if sbuild:
			subprocess.check_call(LogCall(["sudo", "piuparts", 
						"--lvm-volume="+lvm+"/"+dist+"_chroot",
						"-N",
						"-W", 
						"--single-changes-list",
						"--log-level=info", 
						"--ignore=/var/log/apt/history.log", 
						"--mirror=http://archive.ubuntu.com/ubuntu main universe restricted multiverse", 
						changes_file]))
		else:
			subprocess.check_call(LogCall(["sudo", "piuparts", 
						"--pbuilder",
						"-N",
						"-W", 
						"--single-changes-list",
						"--log-level=info", 
						"--ignore=/var/log/apt/history.log", 
						"--mirror=http://archive.ubuntu.com/ubuntu main universe restricted multiverse", 
						changes_file]))
	except subprocess.CalledProcessError:
		print >> sys.stderr, "E: %s failed to install. Please check log" % (changes_file)

def main(bug_number, package, version, section, update, verbose=False, silent=False):
	launchpad = get_launchpad("ubuntu-dev-tools")

	bug = launchpad.bugs[bug_number]

	task = list(bug.bug_tasks)[0]
	
	if package is None:
		package = task.bug_target_name.split(" ")[0]
	if version is None:
		version = get_version(bug.title)
	print "package:", package
	print "version:", version
	dsc_file = get_source(package, version, section)
	
	# update pbuilder
	if update:
		if sbuild:
			subprocess.call(LogCall(["sbuild-update", dist]))
		else:
			subprocess.call(LogCall(["sudo", "env", "DIST=lucid", "pbuilder", "update"]))
	
	build_source(dsc_file)
	
	if piuparts:
		test_install(dsc_file)

	print bug.title
	print task.assignee
	print task.status
	raw_input_exit_on_ctrlc('Press [Enter] to continue or [Ctrl-C] to abort. ')

	people = launchpad.people
	uus = people['ubuntu-universe-sponsors']
	bug.unsubscribe(person=uus)
	print "uus unsubscribed"
	task.transitionToAssignee(assignee=None)
	print "unassigned me"
	task.transitionToStatus (status="Triaged")
	print "status set to Triaged"
	if task.importance == "Undecided":
		task.transitionToImportance(importance="Wishlist")
		print "importance set to Wishlist"
	if piuparts:	
		bug.newMessage(content="package builds and installs, sync request ACK'd")
	else:
		bug.newMessage(content="package builds, sync request ACK'd")
	print "Ack comment added"
	aa = people['ubuntu-archive']
	bug.subscribe(person=aa)
	print "Archive admin subscribed"
	bug.subscribe(person=launchpad.me)
	print "subscribed me"

def usage():
	print """ack-sync <bug numbers>

  -h, --help                displays this help
  -l, --lvm                 lvm root dev directory, used for sbuild and piuparts. Default is /dev/vg
  -p, --package=<package>   set the package
  -P, --with_piuparts       use piuparts to check the instalability of the package
      --section=<section>   Debian section (one of main, contrib, non-free)
  -s, --silent              be more silent
  -S, --with_sbuild         use sbuild instead of pbuilder
  -u, --update              updates pbuilder before building
  -v, --verbose             be more verbosive
  -V, --version=<version>   set the version"""

if __name__ == '__main__':
	try:
		long_opts = ["help", "package=", "section=", "silent", "update",
				"verbose", "version=", "with_sbuild", "with_piuparts", "lvm="]
		opts, args = getopt.gnu_getopt(sys.argv[1:], "hp:sSuvV:", long_opts)
	except getopt.GetoptError, e:
		# print help information and exit:
		print >> sys.stderr, str(e) # will print something like "option -a not recognized"
		sys.exit(COMMAND_LINE_SYNTAX_ERROR)

	package = None
	sbuild = False
	section = "main"
	silent = False
	update = False
	verbose = False
	version = None
	piuparts = False
	lvm = "/dev/vg"

	for o, a in opts:
		if o in ("-h", "--help"):
			usage()
			sys.exit()
		elif o in ("-l", "--lvm"):
			lvm = a
		elif o in ("-p", "--package"):
			package = a
		elif o in ("-P", "--with_piuparts"):
			piuparts = True
		elif o in ("--section"):
			section = a
		elif o in ("-s", "--silent"):
			silent = True
		elif o in ("-S", "--with_sbuild"):
			sbuild = True
		elif o in ("-u", "--update"):
			update = True
		elif o in ("-v", "--verbose"):
			verbose = True
		elif o in ("-V", "--version"):
			version = a
		else:
			assert False, "unhandled option"

	if len(args) != 1:
		if not silent:
			print >> sys.stderr, "E: You must specify bug number."
		sys.exit(COMMAND_LINE_SYNTAX_ERROR)

	try:
		bug_number = int(args[0])
	except:
		if not silent:
			print >> sys.stderr, "E: '%s' is not a valid bug number." % args[0]
		sys.exit(COMMAND_LINE_SYNTAX_ERROR)
	main(bug_number, package, version, section, update, verbose, silent)
