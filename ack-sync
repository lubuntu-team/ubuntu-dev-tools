#!/usr/bin/python
#
# Copyright (C) 2007, Canonical Ltd.
# Copyright (C) 2010, Benjamin Drung <bdrung@ubuntu.com>
#
# It was initial written by Daniel Holbach.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 3.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See file /usr/share/common-licenses/GPL-3 for more details.

import getopt
import os
import re
import subprocess
import sys
import logging
import glob
import fnmatch

from ubuntutools.lp.libsupport import get_launchpad

COMMAND_LINE_SYNTAX_ERROR = 1
VERSION_DETECTION_FAILED = 2

def get_version(title):
	m = re.search("[() ][0-9][0-9a-zA-Z.:+-]*", title)
	if m is None:
		print >> sys.stderr, "Version could not be detected. Please specify it with -V."
		sys.exit(VERSION_DETECTION_FAILED)
	return m.group(0).strip("() ")

def strip_epoch(version):
	parts = version.split(':')
	if len(parts) > 1:
		del parts[0]
	version = ':'.join(parts)
	return version

def LogCall(command):
	command = map(str, command)
	logging.info("Running %s", " ".join(command))
	return command

def get_source(package, version, section):
	assert section in ("main", "contrib", "non-free")

	workdir = "/tmp/ack-sync"
	if not os.path.isdir(workdir):
		os.makedirs(workdir)
	os.chdir(workdir)
	
	if package.startswith("lib"):
		group = package[0:4]
	else:
		group = package[0]

	dsc_file = package + "_" + strip_epoch(version) + ".dsc"
	location = os.path.join("http://ftp.debian.org/debian/pool", section, group, package, dsc_file)
	#print "location:", location
	subprocess.check_call(["dget", "-u", location])
	return dsc_file

def build_source(dsc_file):
	# TODO: use release-info (once available)
	dist = "lucid"
	try:
		if sbuild:
			subprocess.check_call(LogCall(["sbuild", "-c", dist,"-A", dsc_file]))
		else:
			cmd = ["sudo", "env", "DIST=" + dist, "pbuilder", "build",
					"--buildresult", ".", dsc_file]
			subprocess.check_call(LogCall(cmd))
	except subprocess.CalledProcessError:
		print >> sys.stderr, "E: %s failed to build." % (dsc_file)
		sys.exit(1)

def test_install(dsc_file):
	# TODO: use release-info (once available)
	dist = "lucid"
	changes_files=glob.glob(os.path.splitext(dsc_file)[0]+"_*.changes")
	changes_file = ""

	for temp_file in changes_files:
		if not fnmatch.fnmatch(temp_file, '*_source.changes'):
			changes_file = temp_file

	if not (os.path.isfile(changes_file)): # if no file exists at all => exit
		print >> sys.stderr, "E: No .changes file has been generated."
		sys.exit(1)

	try:
		cmd = ["sudo", "piuparts", "-N", "-W", "--single-changes-list",
				"--log-level=info", "--ignore=/var/log/apt/history.log",
				"--mirror=http://archive.ubuntu.com/ubuntu main universe restricted multiverse",
				changes_file]
		if sbuild:
			subprocess.check_call(LogCall(cmd + ["--lvm-volume="+lvm+"/"+dist+"_chroot"]))
		else:
			subprocess.check_call(LogCall(cmd + ["--pbuilder"]))
	except subprocess.CalledProcessError:
		print >> sys.stderr, "E: %s failed to install. Please check log" % (changes_file)

def main(bug_numbers, package, version, section, update, verbose=False, silent=False):
	# update pbuilder
	if update:
		if sbuild:
			subprocess.call(LogCall(["sbuild-update", dist]))
		else:
			cmd = ["sudo", "env", "DIST=lucid", "pbuilder", "update"]
			subprocess.call(LogCall(cmd))

	launchpad = get_launchpad("ubuntu-dev-tools")

	for bug_number in bug_numbers:
		bug = launchpad.bugs[bug_number]

		task = list(bug.bug_tasks)[0]
	
		if package is None or len(bug_numbers) > 1:
			package = task.bug_target_name.split(" ")[0]
			if package == "ubuntu":
				# no source package was defined. Guessing that the second word in
				# the title is the package name
				package = bug.title.split(" ")[1]
		if version is None or len(bug_numbers) > 1:
			version = get_version(bug.title)
		print "package:", package
		print "version:", version
		dsc_file = get_source(package, version, section)

		build_source(dsc_file)
	
		if piuparts:
			test_install(dsc_file)

		print bug.title
		print task.assignee
		print task.status
		try:
			raw_input('Press [Enter] to continue or [Ctrl-C] to abort.')
		except KeyboardInterrupt:
			continue

		people = launchpad.people
		uus = people['ubuntu-universe-sponsors']
		bug.unsubscribe(person=uus)
		print "uus unsubscribed"
		task.transitionToAssignee(assignee=None)
		print "unassigned me"
		task.transitionToStatus (status="Triaged")
		print "status set to Triaged"
		if task.importance == "Undecided":
			task.transitionToImportance(importance="Wishlist")
			print "importance set to Wishlist"
		if piuparts:
			bug.newMessage(content="package builds and installs, sync request ACK'd")
		else:
			bug.newMessage(content="package builds, sync request ACK'd")
		print "Ack comment added"
		aa = people['ubuntu-archive']
		bug.subscribe(person=aa)
		print "Archive admin subscribed"
		bug.subscribe(person=launchpad.me)
		print "subscribed me"

def usage():
	print """ack-sync <bug numbers>

  -h, --help                displays this help
  -l, --lvm                 lvm root dev directory, used for sbuild and piuparts
                            default is /dev/vg
  -p, --package=<package>   set the package
  -P, --with-piuparts       use piuparts to check the instalability
      --section=<section>   Debian section (one of main, contrib, non-free)
  -s, --silent              be more silent
  -S, --with-sbuild         use sbuild instead of pbuilder
  -u, --update              updates pbuilder before building
  -v, --verbose             be more verbosive
  -V, --version=<version>   set the version"""

if __name__ == '__main__':
	try:
		long_opts = ["help", "lvm=", "package=", "section=", "silent", "update",
				"verbose", "version=", "with-sbuild", "with-piuparts"]
		opts, args = getopt.gnu_getopt(sys.argv[1:], "hp:PsSuvV:", long_opts)
	except getopt.GetoptError, e:
		# will print something like "option -a not recognized"
		print >> sys.stderr, str(e)
		sys.exit(COMMAND_LINE_SYNTAX_ERROR)

	package = None
	sbuild = False
	section = "main"
	silent = False
	update = False
	verbose = False
	version = None
	piuparts = False
	lvm = "/dev/vg"

	for o, a in opts:
		if o in ("-h", "--help"):
			usage()
			sys.exit()
		elif o in ("-l", "--lvm"):
			lvm = a
		elif o in ("-p", "--package"):
			package = a
		elif o in ("-P", "--with-piuparts"):
			piuparts = True
		elif o in ("--section"):
			section = a
		elif o in ("-s", "--silent"):
			silent = True
		elif o in ("-S", "--with-sbuild"):
			sbuild = True
		elif o in ("-u", "--update"):
			update = True
		elif o in ("-v", "--verbose"):
			verbose = True
		elif o in ("-V", "--version"):
			version = a
		else:
			assert False, "unhandled option"

	if len(args) == 0:
		if not silent:
			print >> sys.stderr, "E: You must specify at least one bug number."
		sys.exit(COMMAND_LINE_SYNTAX_ERROR)

	bug_numbers = []
	for arg in args:
		try:
			number = int(arg)
		except:
			if not silent:
				print >> sys.stderr, "E: '%s' is not a valid bug number." % arg
			sys.exit(COMMAND_LINE_SYNTAX_ERROR)
		bug_numbers.append(number)

	main(bug_numbers, package, version, section, update, verbose, silent)
